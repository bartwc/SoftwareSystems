/*
 * generated by Xtext 2.33.0
 */
package xray.generator

import xray.xRayDSL.SystemType
import xray.xRayDSL.ThreePedals
import xray.xRayDSL.SixPedals

abstract class RUSTGenerator {

	def static CharSequence toToml()'''
	[package]
	name = "example"
	version = "0.1.0"
	edition = "2021"

	[dependencies]
	# this is the simulation library
	tudelft-xray-sim = "1.0.0"

	# logging libraries
	simple_logger = "4.0.0"
	log = "0.4"
	'''

	def static CharSequence toRust(SystemType root)'''«»
	// Import types from the simulation library.
	use tudelft_xray_sim::*;
	// Import enum variants to make this example a bit easier to read.
	use Dose::*;
	use Mode::*;
	use Projection::*;

	use log::info;

	fn main() {
	    // Initialize logger.
	    simple_logger::init().unwrap();
	    // Run simulation with your own implementation of the control logic.
	    run_single_plane_sim(Logic::default())
	}

	/// Example control logic for a two plane system.
	/// The pedal mapping is based on the example mapping given in the DSL assignment.
    #[derive(Default)]
    struct Logic {
        /// keep track of the selected projection
        selected: Projection,
        selected_dose: Dose,
        selected_mode: Mode,
        p1_on: bool,
        p2_on: bool,
        p3_on: bool,
        //p4_on: bool,
        p5_on: bool,
        // p6_on: bool,
        // you can have whatever other information that you want here
    }

    impl PedalMapper for Logic {
        /// We use an associated type to determine which pedal enum is used.
        /// Single-plane systems use the `ThreePedals` enum, while
        /// two-plane systems use `SixPedals`.
        /// Whether you used the correct type is checked at compile time.
	    type Pedals = «type2Code(root.configuration)»;


	    fn on_press(&self, pedal: Self::Pedals) -> Option<Request> {
	        use «type2Code(root.configuration)»::*;
	        Some(match pedal {
	            «IF root.configuration instanceof ThreePedals»
	             Pedal1 => Request::start(«root.configuration.pedal1.projection»,«root.configuration.pedal1.dosetype»,«root.configuration.pedal1.function»),
	             Pedal2 => Request::start(«root.configuration.pedal2.projection»,«root.configuration.pedal2.dosetype»,«root.configuration.pedal2.function»),
	             Pedal3 => Request::start(«root.configuration.pedal3.projection»,«root.configuration.pedal3.dosetype»,«root.configuration.pedal3.function»),
	            «ENDIF»
	        })
	    }

	    fn on_release(&self, pedal: Self::Pedals) -> Option<Request> {
	        use «type2Code(root.configuration)»::*;
	        Some(match pedal {
	            «IF root.configuration instanceof ThreePedals»
	             Pedal1 => Request::stop(«root.configuration.pedal1.projection»,«root.configuration.pedal1.dosetype»,«root.configuration.pedal1.function»),
	             Pedal2 => Request::stop(«root.configuration.pedal2.projection»,«root.configuration.pedal2.dosetype»,«root.configuration.pedal2.function»),
	             Pedal3 => Request::stop(«root.configuration.pedal3.projection»,«root.configuration.pedal3.dosetype»,«root.configuration.pedal3.function»),
	            «ENDIF»
	        })
	    }
	}

    impl ActionLogic<true> for Logic {
        /// Naive implementation of request handling which does not handle
        /// multiple pedals being pressed at once.
        fn handle_request(&mut self, request: Request, controller: &mut Controller<true>) {
            // This is how you can get access to the planes in case you want to inspect their status.
            let _frontal = controller.frontal();
            let _lateral = controller.lateral();

            // Custom logging of requests.
            info!("Processing request: {request:?}");

            // In your own code (as well as the code that you generate),
            // you should do checks before using the controller to
            // start and stop X-rays.
            match request {
                Request::Start {
                    projection,
                    dose,
                    mode,
                } => {
                    if projection == Frontal {
                        self.p1_on = true;
                        if self.p3_on == false {
                            controller.activate_xray(projection, dose, mode);
                        }
                    } else if projection == Lateral {
                        self.p2_on = true;
                        if self.p3_on == false {
                            controller.activate_xray(projection, dose, mode);
                        }
                    }
                    if projection == Biplane {
                        self.p3_on = true;
                        if self.p1_on == false && self.p2_on == true {
                            controller.activate_xray(Frontal, dose, mode);
                        } else if self.p1_on == true && self.p2_on == false {
                            controller.activate_xray(Lateral, dose, mode);
                        } else if self.p1_on == false && self.p2_on == false {
                            controller.activate_xray(Biplane, dose, mode);
                        }
                    }
                    self.selected = projection;
                    self.selected_dose = dose;
                    self.selected_mode = mode;
                }

                Request::Stop { projection,
                    dose,
                    mode, } => {
                    if projection == Frontal {
                        self.p1_on = false;
                    } else if projection == Lateral {
                        self.p2_on = false;
                    } else if projection == Biplane {
                        self.p3_on = false;
                    }
                    controller.deactivate_xray();
                    if projection != Biplane && self.p3_on == true {
                        controller.activate_xray(Biplane, dose, mode);
                    }
                    if projection != Frontal && self.p1_on == true && self.p3_on == false {
                        self.selected = Frontal;
                        controller.activate_xray(Frontal, dose, mode);
                    }
                    if projection != Lateral && self.p2_on == true && self.p3_on == false {
                        self.selected = Lateral;
                        controller.activate_xray(Lateral, dose, mode);
                    }
                }

            Request::ToggleSelectedProjection => {
                if self.p1_on == false && self.p2_on == false && self.p3_on == false {
                    self.selected = match self.selected {
                        Frontal => Lateral,
                        Lateral => Biplane,
                        Biplane => Frontal,
                    }
                };
                info!("Selected: {:?}", self.selected);
            }

            Request::StartSelectedProjection { dose, mode } => {
                controller.deactivate_xray();
                controller.activate_xray(self.selected, dose, mode)
            }

            Request::StopSelectedProjection { dose, mode  } => {
                if self.p1_on == true || self.p2_on == true || self.p3_on == true {
                    controller.deactivate_xray();
                    controller.activate_xray(self.selected, dose, mode);
	        }
	    }
	}
	'''

	def static dispatch type2Code(ThreePedals pedal)'''
		ThreePedals'''

	def static dispatch type2Code(SixPedals pedal)'''
		SixPedals'''
}